# S07E01 - oKanban - D√©marrage du front

:warning: Le retour du front ! Pensez √† `console.log` pour tester r√©guli√®rement (voire √† chaque ligne !) :warning:

:warning: Pensez √† mettre en place ESLint dans votre projet (tr√®s bon garde-fou sur du code frontend !) :warning:

## Static force !

Pour ce projet, le **frontend** est enti√®rement ind√©pendant du backend, et communiquera avec lui via son API. 

C√¥t√© frontend, tout va donc se passer dans le navigateur. On va donc coder directement des fichiers statiques (`HTML`, `CSS`, `JS`). Retour en S2, en quelques sortes !

Petit rappel, pour lancer le front, on a plusieurs options : 

<details><summary>
1. on ouvre le fichier dans son navigateur directement...
</summary>

<details><summary>
1.1 √† l'aide de la ligne de commande
</summary>

- `google-chrome index.html`
- ou bien `open -a 'Google Chrome' index.html`
- ou encore `chromium index.html`
- ou bien encore `chromium-browser index.html`
- ou bien bien encore `firefox index.html`
- ou n'importe quel autre navigateur si √ßa te fait plaisir :wink:
- enfin, un truc qui marche quoi !
</details>


<details><summary>
1.2 √† l'aide d'une extension VSCode
</summary>

- on installe l'extension `open in browser`
- et y'a plus qu'√† faire clic droit sur le fichier dans VSCode puis `Open in Browser`. 
</details>

<details><summary>
1.3 ou bien √† la mano...
</summary>

- cliquer sur le fichier dans l'explorateur de fichier, et l'ouvrir avec Chrome. 
- classique quoi...
</details>

</details>


<details><summary>
2. ou mieux, on lance un Live Serveur !
</summary>

Cela revient √† lancer un petit serveur "√† part", ind√©pendamment du serveur backend, pour servir uniquement notre front. Si on enregistre un changement, la page se met √† jour dans le navigateur automatiquement (`hot reload`)


<details><summary>
2.1 avec l'extension `Live Server` de VSCode
</summary>

- on installe l'extension `Live Server`
- puis clique droit sur le fichier `index.html` √† la racine de l'app 
- et `Open With Live Server`

</details>

<details><summary>
2.2 alternativement, il existe des live servers en ligne de commande
</summary>

Par exemple :
- `npm install -g live-server`
- `live-server` (depuis la racine du projet, o√π le fichier `index.html` est pr√©sent)

</details>

</details>


## Prise en main du code

Commencer par **lire les fichiers fournis** et le comprendre globalement. L'int√©gration qui nous est propos√©e utilise le framework CSS Bulma.

Un petit tour sur la [doc](https://bulma.io/) ne fait jamais de mal !


## 1. Ouvrir la modale

Tu as d√ª remarquer le bouton `Ajouter une liste`. Mais ce bouton... ne fait rien !

Tu as d√ª aussi remarquer la pr√©sence d'une `<div class="modal">` dans le code.

> Une modale est une fen√™tre fictive qui s'ouvre dans le navigateur par dessus le contenu courant, √† la mani√®re d'une popup.

**Objectif** : lorsque l'on clique sur le bouton, la modale apparait. √Ä toi de jouer !

<details><summary>De l'aide ?</summary>

- L'id√©e est d'ajouter la classe `is-active` √† la modale pour l'afficher.
  - lors que l'utilisateur clique sur le bouton, on ajoute cette classe.

<details><summary>
Pseudo code
</summary>

```js
// selectionner le bouton (`getElementById`)
// √©couter le click sur le bouton, et en cas de click : (`addEventListener`)
//   selectionner la div modale
//   lui ajouter la classe 'is-active'
```
</details>

<details>
<summary>
Un peu de rangement ?
</summary>

- On peut regrouper ces instructions dans une m√©thode `listenToClickOnAddListButton`. Et l'appeller, bien entendu.
- On peut extraire le code qui ouvre sp√©cifiquement la modale dans une m√©thode `openAddListModal`.

</details>

</details>

## 2. Fermer la modale

Rep√®re les 2 boutons pour fermer la modale : la croix `x` en haut √† droite, et le bouton `Annuler`. En cliquant sur un de ces deux boutons, la modale doit disparaitre. A toi de jouer !

- **Tips :** on peut selectionner la croix par la classe `.close`
- **Bonus :** de m√™me, si l'utilisateur clique sur le fond gris√© derri√®re la modale, celle-ci doit se fermer.

<details>
<summary>De l'aide ?</summary>

L'id√©e est de retirer la classe `is-active` lors d'un clic sur l'un des deux boutons. 

Pour le rangement, inspire toi de ce qui a √©t√© fait √† l'√©tape pr√©c√©dente. On pourra par exemple ajouter les m√©thodes : 
- `listenToClickOnModalClosingElements` :
  - on selectionner les boutons, et on √©coute le clic sur chaque bouton. 
- `closeModals` : 
  - ie, une m√©thode qui retire la classe `is-active` de toutes les modales (oui, c'est un poil bourrin, mais √ßa √©vitera d'avoir √† le refaire pour chacune des modales qu'on va rajouter)
- `listenToUserActions` : 
  - √©ventuellement, on peut regrouper les deux ajouts de listeners existants (`listenToXXXX`) dans une m√©thode englobante.

</details>

## 3. Valider le formulaire

Intercepte la soumission du formulaire de la modale `ajouter une liste`. Emp√™che le comportement par d√©faut de l'√©v√®nement, puis r√©cup√®re les donn√©es du formulaire. Ensuite, on passe les donn√©es en param√®tre √† une m√©thode `addListToListsContainer(listData)` (fonction √† coder √† l'√©tape suivante et en attendant, un `console.log` suffiera).

<details>
<summary>De l'aide ?</summary>

- `listenToSubmitOnAddListForm` :
  - on selectionne le formulaire de la modale
  - on √©coute l'√©v√®nement `submit` et on pense √† `preventDefault()` pour √©viter sa soumission automatique.
  - on recup√®re les donn√©es du formulaire, en allant jeter un oeil √† la documentation de [FormData](https://developer.mozilla.org/fr/docs/Web/API/FormData), et on `console.log` les donn√©es r√©cup√©r√©es !
  - on `reset` le formulaire pour la prochaine utilisation ! 
  - enfin, on appelle une fonction `addListToListsContainer` en lui passant les donn√©es de la liste, que l'on codera √† l'√©tape suivante.
  - et on oublie pas de fermer la modale apr√®s √ßa !

</details>

## 4. Fabriquer une nouvelle liste

C'est le moment d'impl√©menter la m√©thode `addListToListsContainer`. Cette m√©thode doit cr√©er de toute pi√®ce une nouvelle liste, et l'ajouter dans le DOM.

On pourrait utiliser des `document.createElement` √† tout va, mais on va vite avoir un probl√®me : on a un sacr√© paquet d'√©l√©ments √† cr√©er, √ßa va prendre un temps fou √† √©crire !

Heureusement, HTML nous propose un syst√®me pour pallier ce souci : les [templates](https://developer.mozilla.org/fr/docs/Web/HTML/Element/template).

1. Un [`template`](https://developer.mozilla.org/fr/docs/Web/HTML/Element/template) est d√©j√† fourni dans le HTML : 
  - c'est la structure d'une `Liste`, vide de cartes.
  - il n'apparait pas dans le DOM tant qu'il n'est pas clon√©.
  - ce template poss√®de un `id` explicite afin de le cibler facilement. 
2. Dans la m√©thode `addListToListsContainer`, il faut ensuite :
  - r√©cup√©rer ce template
  - le **cloner** dans une variable qu'on nommera `newListElement` (cf. [doc - cloneNode](https://developer.mozilla.org/fr/docs/Web/Web_Components/Utilisation_des_templates_et_des_slots)).
     - on r√©cup√®re alors un `documentFragment` sur lequel on pourra appeler `querySelector` pour r√©cup√©rer les sous √©l√©ments √† modifier !
  - on ins√®re ensuite ce `documentFragment` (~= √©l√©ment) dans le conteneur des listes, par exemple, en utilisant `appendChild` ou `insertBefore`.
3. Enfin, on remplace le titre de la nouvelle liste cr√©√©e par celui choisit par l'utilisateur. Il faut donc **selectionner** l'√©l√©ment du `template` qui doit contenir le titre. Mais pour cela, comment faire ? 
    - ajouter un `id` √† cette div ? Et **non**, car on va ins√©rer plusieurs listes, et on ne peut pas avoir 2 fois le m√™me ID dans un document HTML.
    - une `classe` ? **Pourquoi pas**, mais c'est plut√¥t r√©serv√© pour le styling. A vous de voir.
    - un attribut `slot` ? **Bonne id√©e** :
      - par exemple, en rajoutant `slot="list-name"` sur un √©l√©ment du template, on peut alors le cibler via `newListElement.querySelector('[slot="list-name"]')`, puis changer ses propri√©t√©s, son texte, etc...


## 5. Fabriquer une nouvelle carte

### Pr√©parer le terrain

Dans le `HTML` :
- Cr√©er une **modale** avec l'id `add-card-modal`, en t'inspirant tr√®s largement de la modale d√©j√† existante.
- Cr√©er un **template** avec l'id `card-template` pour une carte √† cr√©er, sur le m√™me principe que pour les listes.

Dans le `JS` de l'√©tape pr√©c√©dente :
- Lorsqu'on inserait une liste dans le DOM √† l'√©tape pr√©c√©dente, on veut aussi √† pr√©sent ajouter l'ID de la liste au DOM, dans l'objectif de savoir dans quelle liste on va ins√©rer la carte √† cr√©er :
  - on g√©n√®re donc un nombre al√©atoire `listId` (bient√¥t, √ßa sera au serveur de s'en charger ! Mais en attendant...).
  - que l'on ajoute comme attribut √† l'√©lement avant l'insertion dans le DOM via `element.setAttribute("id", "list-42");` o√π `42` est la `listId`
    - m√™me principe, on peut se servir des `slot` pour r√©cup√©rer l'√©l√©ment o√π poser l'id depuis le Fragment. 

### Interactions

Pour faciliter nos affaires, on travaillera UNIQUEMENT avec les listes qu'on est capable d'ajouter dynamiquement dans le DOM. On peut m√™me commenter les listes et cartes qui sont actuellement hard-cod√©es dans le HTML, histoire de faire place nette.

Lors d'un clic sur le bouton `+` d'une liste, on doit :
- afficher la modale `add-card-modal`
- ET rajouter "quelque part dans les m√©tadonn√©es" de cette modale l'id de la liste qui vient d'√™tre cliqu√©e.
  - on retrouve donc l'ID de la liste cliqu√©e.
  - et on passe cet ID √† notre modal, par exemple, en utilisant les [`dataset`](https://developer.mozilla.org/fr/docs/Web/API/HTMLElement/dataset).
    - (ou on peut aussi ajouter un `input` de type `hidden` dans le formulaire avec l'id).

### Insertion

Et enfin, valider le formulaire doit ajouter une nouvelle carte dans le DOM.

<details>
<summary>Help encore !</summary>

- `listenToSubmitOnAddCardForm` : 
  - on √©coute le `submit` sur le form, et en cas de submit...
- `handleAddCardFormSubmit` : 
  - on oublie pas de `preventDefault()`
  - on r√©cup√®re les donn√©es du `form` via `new FormData(form)`
  - on recup√®re l'ID de la liste via les `dataset` de la modale (ou l'input `hidden`, selon ce que vous avez fait pr√©c√©demment)
- `addCardToList(cardData, listId)` 
  - comme pr√©c√©demment, on clone le `template` et on remplace par les valeurs donn√©es par l'utilisateur
  - et on l'ins√®re dans la bonne liste (√ßa tombe bien, on a son ID)

</details>

## Fin du jour 1 !

C'√©tait (tr√®s) chaud, mais on corrigera tout √ßa tranquillement üôÇ !
