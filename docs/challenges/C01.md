# S07E01 - oKanban - Démarrage du front

:warning: Le retour du front ! Pensez à `console.log` pour tester régulièrement (voire à chaque ligne !) :warning:

:warning: Pensez à mettre en place ESLint dans votre projet (très bon garde-fou sur du code frontend !) :warning:

## Static force !

Pour ce projet, le **frontend** est entièrement indépendant du backend, et communiquera avec lui via son API. 

Côté frontend, tout va donc se passer dans le navigateur. On va donc coder directement des fichiers statiques (`HTML`, `CSS`, `JS`). Retour en S2, en quelques sortes !

Petit rappel, pour lancer le front, on a plusieurs options : 

<details><summary>
1. on ouvre le fichier dans son navigateur directement...
</summary>

<details><summary>
1.1 à l'aide de la ligne de commande
</summary>

- `google-chrome index.html`
- ou bien `open -a 'Google Chrome' index.html`
- ou encore `chromium index.html`
- ou bien encore `chromium-browser index.html`
- ou bien bien encore `firefox index.html`
- ou n'importe quel autre navigateur si ça te fait plaisir :wink:
- enfin, un truc qui marche quoi !
</details>


<details><summary>
1.2 à l'aide d'une extension VSCode
</summary>

- on installe l'extension `open in browser`
- et y'a plus qu'à faire clic droit sur le fichier dans VSCode puis `Open in Browser`. 
</details>

<details><summary>
1.3 ou bien à la mano...
</summary>

- cliquer sur le fichier dans l'explorateur de fichier, et l'ouvrir avec Chrome. 
- classique quoi...
</details>

</details>


<details><summary>
2. ou mieux, on lance un Live Serveur !
</summary>

Cela revient à lancer un petit serveur "à part", indépendamment du serveur backend, pour servir uniquement notre front. Si on enregistre un changement, la page se met à jour dans le navigateur automatiquement (`hot reload`)


<details><summary>
2.1 avec l'extension `Live Server` de VSCode
</summary>

- on installe l'extension `Live Server`
- puis clique droit sur le fichier `index.html` à la racine de l'app 
- et `Open With Live Server`

</details>

<details><summary>
2.2 alternativement, il existe des live servers en ligne de commande
</summary>

Par exemple :
- `npm install -g live-server`
- `live-server` (depuis la racine du projet, où le fichier `index.html` est présent)

</details>

</details>


## Prise en main du code

Commencer par **lire les fichiers fournis** et le comprendre globalement. L'intégration qui nous est proposée utilise le framework CSS Bulma.

Un petit tour sur la [doc](https://bulma.io/) ne fait jamais de mal !


## 1. Ouvrir la modale

Tu as dû remarquer le bouton `Ajouter une liste`. Mais ce bouton... ne fait rien !

Tu as dû aussi remarquer la présence d'une `<div class="modal">` dans le code.

> Une modale est une fenêtre fictive qui s'ouvre dans le navigateur par dessus le contenu courant, à la manière d'une popup.

**Objectif** : lorsque l'on clique sur le bouton, la modale apparait. À toi de jouer !

<details><summary>De l'aide ?</summary>

- L'idée est d'ajouter la classe `is-active` à la modale pour l'afficher.
  - lors que l'utilisateur clique sur le bouton, on ajoute cette classe.

<details><summary>
Pseudo code
</summary>

```js
// selectionner le bouton (`getElementById`)
// écouter le click sur le bouton, et en cas de click : (`addEventListener`)
//   selectionner la div modale
//   lui ajouter la classe 'is-active'
```
</details>

<details>
<summary>
Un peu de rangement ?
</summary>

- On peut regrouper ces instructions dans une méthode `listenToClickOnAddListButton`. Et l'appeller, bien entendu.
- On peut extraire le code qui ouvre spécifiquement la modale dans une méthode `openAddListModal`.

</details>

</details>

## 2. Fermer la modale

Repère les 2 boutons pour fermer la modale : la croix `x` en haut à droite, et le bouton `Annuler`. En cliquant sur un de ces deux boutons, la modale doit disparaitre. A toi de jouer !

- **Tips :** on peut selectionner la croix par la classe `.close`
- **Bonus :** de même, si l'utilisateur clique sur le fond grisé derrière la modale, celle-ci doit se fermer.

<details>
<summary>De l'aide ?</summary>

L'idée est de retirer la classe `is-active` lors d'un clic sur l'un des deux boutons. 

Pour le rangement, inspire toi de ce qui a été fait à l'étape précédente. On pourra par exemple ajouter les méthodes : 
- `listenToClickOnModalClosingElements` :
  - on selectionner les boutons, et on écoute le clic sur chaque bouton. 
- `closeModals` : 
  - ie, une méthode qui retire la classe `is-active` de toutes les modales (oui, c'est un poil bourrin, mais ça évitera d'avoir à le refaire pour chacune des modales qu'on va rajouter)
- `listenToUserActions` : 
  - éventuellement, on peut regrouper les deux ajouts de listeners existants (`listenToXXXX`) dans une méthode englobante.

</details>

## 3. Valider le formulaire

Intercepte la soumission du formulaire de la modale `ajouter une liste`. Empêche le comportement par défaut de l'évènement, puis récupère les données du formulaire. Ensuite, on passe les données en paramètre à une méthode `addListToListsContainer(listData)` (fonction à coder à l'étape suivante et en attendant, un `console.log` suffiera).

<details>
<summary>De l'aide ?</summary>

- `listenToSubmitOnAddListForm` :
  - on selectionne le formulaire de la modale
  - on écoute l'évènement `submit` et on pense à `preventDefault()` pour éviter sa soumission automatique.
  - on recupère les données du formulaire, en allant jeter un oeil à la documentation de [FormData](https://developer.mozilla.org/fr/docs/Web/API/FormData), et on `console.log` les données récupérées !
  - on `reset` le formulaire pour la prochaine utilisation ! 
  - enfin, on appelle une fonction `addListToListsContainer` en lui passant les données de la liste, que l'on codera à l'étape suivante.
  - et on oublie pas de fermer la modale après ça !

</details>

## 4. Fabriquer une nouvelle liste

C'est le moment d'implémenter la méthode `addListToListsContainer`. Cette méthode doit créer de toute pièce une nouvelle liste, et l'ajouter dans le DOM.

On pourrait utiliser des `document.createElement` à tout va, mais on va vite avoir un problème : on a un sacré paquet d'éléments à créer, ça va prendre un temps fou à écrire !

Heureusement, HTML nous propose un système pour pallier ce souci : les [templates](https://developer.mozilla.org/fr/docs/Web/HTML/Element/template).

1. Un [`template`](https://developer.mozilla.org/fr/docs/Web/HTML/Element/template) est déjà fourni dans le HTML : 
  - c'est la structure d'une `Liste`, vide de cartes.
  - il n'apparait pas dans le DOM tant qu'il n'est pas cloné.
  - ce template possède un `id` explicite afin de le cibler facilement. 
2. Dans la méthode `addListToListsContainer`, il faut ensuite :
  - récupérer ce template
  - le **cloner** dans une variable qu'on nommera `newListElement` (cf. [doc - cloneNode](https://developer.mozilla.org/fr/docs/Web/Web_Components/Utilisation_des_templates_et_des_slots)).
     - on récupère alors un `documentFragment` sur lequel on pourra appeler `querySelector` pour récupérer les sous éléments à modifier !
  - on insère ensuite ce `documentFragment` (~= élément) dans le conteneur des listes, par exemple, en utilisant `appendChild` ou `insertBefore`.
3. Enfin, on remplace le titre de la nouvelle liste créée par celui choisit par l'utilisateur. Il faut donc **selectionner** l'élément du `template` qui doit contenir le titre. Mais pour cela, comment faire ? 
    - ajouter un `id` à cette div ? Et **non**, car on va insérer plusieurs listes, et on ne peut pas avoir 2 fois le même ID dans un document HTML.
    - une `classe` ? **Pourquoi pas**, mais c'est plutôt réservé pour le styling. A vous de voir.
    - un attribut `slot` ? **Bonne idée** :
      - par exemple, en rajoutant `slot="list-name"` sur un élément du template, on peut alors le cibler via `newListElement.querySelector('[slot="list-name"]')`, puis changer ses propriétés, son texte, etc...


## 5. Fabriquer une nouvelle carte

### Préparer le terrain

Dans le `HTML` :
- Créer une **modale** avec l'id `add-card-modal`, en t'inspirant très largement de la modale déjà existante.
- Créer un **template** avec l'id `card-template` pour une carte à créer, sur le même principe que pour les listes.

Dans le `JS` de l'étape précédente :
- Lorsqu'on inserait une liste dans le DOM à l'étape précédente, on veut aussi à présent ajouter l'ID de la liste au DOM, dans l'objectif de savoir dans quelle liste on va insérer la carte à créer :
  - on génère donc un nombre aléatoire `listId` (bientôt, ça sera au serveur de s'en charger ! Mais en attendant...).
  - que l'on ajoute comme attribut à l'élement avant l'insertion dans le DOM via `element.setAttribute("id", "list-42");` où `42` est la `listId`
    - même principe, on peut se servir des `slot` pour récupérer l'élément où poser l'id depuis le Fragment. 

### Interactions

Pour faciliter nos affaires, on travaillera UNIQUEMENT avec les listes qu'on est capable d'ajouter dynamiquement dans le DOM. On peut même commenter les listes et cartes qui sont actuellement hard-codées dans le HTML, histoire de faire place nette.

Lors d'un clic sur le bouton `+` d'une liste, on doit :
- afficher la modale `add-card-modal`
- ET rajouter "quelque part dans les métadonnées" de cette modale l'id de la liste qui vient d'être cliquée.
  - on retrouve donc l'ID de la liste cliquée.
  - et on passe cet ID à notre modal, par exemple, en utilisant les [`dataset`](https://developer.mozilla.org/fr/docs/Web/API/HTMLElement/dataset).
    - (ou on peut aussi ajouter un `input` de type `hidden` dans le formulaire avec l'id).

### Insertion

Et enfin, valider le formulaire doit ajouter une nouvelle carte dans le DOM.

<details>
<summary>Help encore !</summary>

- `listenToSubmitOnAddCardForm` : 
  - on écoute le `submit` sur le form, et en cas de submit...
- `handleAddCardFormSubmit` : 
  - on oublie pas de `preventDefault()`
  - on récupère les données du `form` via `new FormData(form)`
  - on recupère l'ID de la liste via les `dataset` de la modale (ou l'input `hidden`, selon ce que vous avez fait précédemment)
- `addCardToList(cardData, listId)` 
  - comme précédemment, on clone le `template` et on remplace par les valeurs données par l'utilisateur
  - et on l'insère dans la bonne liste (ça tombe bien, on a son ID)

</details>

## Fin du jour 1 !

C'était (très) chaud, mais on corrigera tout ça tranquillement 🙂 !
